### JVM运行时分区
* Java堆

用于存储对象实例，是GC的主要区域。
* 虚拟机帧栈

用于存储方法调用信息，每个线程都有自己的帧栈。
* 方法区

用于存储类信息、常量、静态变量等数据。
* 本地方法区

用于存储本地方法调用信息。
* 程序计数器

用于存储当前线程正在执行的指令地址。
* 运行时常量池

用于存储一些编译期生成的字面量和符号引用。


### 什么是GC
GC是Garbege Collection的缩写，垃圾收集，是Java虚拟机（JVM）中的一种自动内存管理机制，用于回收不再使用的对象所占用的内存空间。

### GC会停止所有线程吗
是的，GC会停止所有线程，这个过程称为"Stop-The-World"。在GC期间，JVM会暂停所有正在运行的线程，以便进行垃圾回收。
Android中频发GC会引起卡顿而不会引起ANR
1. 频繁的创建对象、内存碎片化
2. 内存泄露造成内存不足

### 哪些对象会被GC回收
* 没有被引用的对象 
* GCRoot不可达的对象

### GCRoot对象有哪些
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中Native方法引用的对象

### 如何判断一个对象是否可以被回收
* 引用计数法
* 可达性分析算法

### 对象的引用类型
> 软引用和弱引用和虚引用都可以通过引用队列来观察GC回收情况，`LeakCannary`就是通过引用队列来观察内存泄漏的，如果引用队列中没有被观察的对象引用被回收，说明被观察的对象没有被GC回收，发生了内存泄漏。LeakCannary会记录下被观察的对象，并给出内存泄漏的提示。

* 强引用 GC不会回收强引用的对象
* 软引用 GC可能会在JVM内存不足的时候回收软引用对象
* 弱引用 GC一定会在下一次GC时回收弱引用对象
* 虚引用 随时可能会被GC回收，无法通过虚引用获取对象实例，主要用来跟踪对象被垃圾回收的活动

### JVM垃圾回收算法
* 引用计数
* 复制算法
* 标记清除
* 标记整理
* 分代收集

### JVM垃圾回收器
* Serial收集器
* ParNew收集器
* Parallel收集器
* CMS收集器
* G1收集器
* ZGC收集器
* Shenandoah收集器


### JVM分代回收机制
JVM将堆内存分为新生代和老年代，新生代用于存储新创建的对象，老年代用于存储存活时间较长的对象。
新生代又分为Eden区和两个Survivor区，Eden区和Survivor区的大小比例一般为<b>8:1:1</b>。当Eden区满时，会触发Minor GC，将存活的对象复制到Survivor区，然后清空Eden区。当Survivor区满时，会将存活的对象复制到另一个Survivor区，然后清空Survivor区。当对象在Survivor区存活了足够长的时间后，会被复制到老年代。
