### JVM运行时分区
* Java堆

用于存储对象实例，是GC的主要区域。
* 虚拟机帧栈

用于存储方法调用信息，每个线程都有自己的帧栈。
* 方法区

用于存储类信息、常量、静态变量等数据。
* 本地方法区

用于存储本地方法调用信息。
* 程序计数器

用于存储当前线程正在执行的指令地址。
* 运行时常量池

用于存储一些编译期生成的字面量和符号引用。


### 什么是GC
GC是Garbege Collection的缩写，垃圾收集，是Java虚拟机（JVM）中的一种自动内存管理机制，用于回收不再使用的对象所占用的内存空间。

### GC会停止所有线程吗
是的，GC会停止所有线程，这个过程称为"Stop-The-World"。在GC期间，JVM会暂停所有正在运行的线程，以便进行垃圾回收。
Android中频发GC会引起卡顿而不会引起ANR
1. 频繁的创建对象、内存碎片化
2. 内存泄露造成内存不足

### 哪些对象会被GC回收
* 没有被引用的对象 
* GCRoot不可达的对象

### GCRoot对象有哪些
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中Native方法引用的对象


### JVM垃圾回收算法
* 引用计数
* 复制算法
* 标记清除
* 标记整理
* 分代收集

### JVM垃圾回收器
* Serial收集器
* ParNew收集器
* Parallel收集器
* CMS收集器
* G1收集器
* ZGC收集器
* Shenandoah收集器


### JVM分代回收机制
JVM将堆内存分为新生代和老年代，新生代用于存储新创建的对象，老年代用于存储存活时间较长的对象。
新生代又分为Eden区和两个Survivor区，Eden区和Survivor区的大小比例一般为<b>8:1:1</b>。当Eden区满时，会触发Minor GC，将存活的对象复制到Survivor区，然后清空Eden区。当Survivor区满时，会将存活的对象复制到另一个Survivor区，然后清空Survivor区。当对象在Survivor区存活了足够长的时间后，会被复制到老年代。
