## 创建型模式(5种)

### 工厂模式

#### 特点
- 降低耦合度：工厂模式将对象的创建过程封装在工厂类中，客户端只需通过工厂接口获取对象，而无需知道对象的创建细节，降低了客户端与具体产品类之间的耦合。
- 提高灵活性：当需要新增或修改产品类时，只需修改工厂类的相关代码，而无需修改客户端代码，符合开闭原则（对扩展开放，对修改关闭）。
- 隐藏实现细节：客户端无需知道具体产品的实现细节，只需通过工厂接口进行操作，提高了系统的安全性。

```java
public interface VolvoCar {

}

public class VolvoCarFactory {

    public static VolvoCar getCarByModel(String model) {
        if ("XC60".equals(model)) {
            return new XC60();
        } else if ("S90".equals(model)) {
            return new S90();
        }
        return null;
    }
}
```

### 抽象工厂模式

- 产品族一致性：抽象工厂模式确保创建的对象相互之间是兼容的，属于同一产品家族，有助于保持系统的一致性。
- 易于替换：由于客户端只依赖于抽象接口，而不直接依赖具体类，因此可以轻松替换整个产品家族的实现，而无需修改客户端代码。
- 隐藏实现细节：客户端无需知道具体产品的实现细节，只需要了解抽象工厂接口，从而降低了系统的复杂度。

```java
public interface VolvoCarFactory {
    public VolvoCar getCar();
}

public class XC60Factory implements VolvoCarFactory {
    @Override
    public VolvoCar getCar() {
        return new XC60();
    }
}

public class S90Factory implements VolvoCarFactory {
    @Override
    public VolvoCar getCar() {
        return new S90();
    }
}
```

### 单例模式

#### 特点

- 确保对象只创建一次，减少资源的浪费
- 提供全局访问点，提高代码的可维护性
- 简化代码结构，避免多线程问题

#### 实现方式

1. 静态内部类Holder

    ```java
    public class Singleton {
        private Singleton() {
        }

        private static class Holder {
            private static final Singleton INSTANCE = new Singleton();
        }

        public static Singleton getInstance() {
            return Holder.INSTANCE;
        }
    }
    ```
2. 双重检查锁

    ```java
    public class Singleton {
        private volatile static Singleton instance;

        private Singleton() {
        }

        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
    ```
3. 枚举模式

    ```java
    enum class Singleton {
        INSTANCE;
    }
    ```
- 线程安全：无需额外的同步代码。
- 防止反射和反序列化攻击：确保单例的唯一性。
- 简洁性：代码量少，易于理解和维护。
- 性能高：由于枚举的特殊性，其性能通常优于其他单例实现方式。

4. 饿汉式

    ```java
    public class Singleton {
        private static final Singleton INSTANCE = new Singleton();

        private Singleton() {
        }

        public static Singleton getInstance() {
            return INSTANCE;
        }
    }
    ```

### 建造者模式

建造者模式（Builder Pattern），也被称为生成器模式，是一种创建型设计模式。该模式的核心思想是将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。以下是对建造者模式的详细介绍：

#### 一、定义与原理

    定义：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
    原理：通过定义一个抽象建造者接口，并提供一个指挥者类来指导具体建造者如何一步步构建最终的产品对象。用户只需要指定需要建造的类型，就可以得到该类型对应的产品实例，而无需关心建造过程的细节。

#### 二、结构组成

    建造者模式通常包含以下四个角色：
    产品（Product）：复杂对象，由多个部件组成，具有一定的功能和特点。
    抽象建造者（Builder）：定义了创建产品各个部件的抽象方法，通常包括创建和装配各个部件的方法。
    具体建造者（Concrete Builder）：实现了抽象建造者接口，负责具体的产品构建和装配过程，并返回最终的产品。
    指挥者（Director）：调用具体建造者来创建复杂对象的各个部分，按照特定的顺序和逻辑来组织产品的创建过程。

##### 三、适用场景

    建造者模式适用于以下场景：
    结构复杂：对象有非常复杂的内部结构，有很多属性。
    分离创建和使用：想把复杂对象的创建和使用分离。
    构建过程复杂：当一个对象的构建过程需要多个步骤，且这些步骤之间存在复杂的依赖关系时，适合使用建造者模式。
    灵活构建：需要构建的对象具有多种表示形式，且构建过程需要具备一定的灵活性时，可以使用建造者模式。

#### 四、优缺点

- 优点

    封装性好：将复杂对象的构建过程封装在具体建造者类中，客户端只需要知道如何通过指挥者来构建对象即可，无需关心具体的构建过程。
    易于扩展：由于具体建造者类和指挥者类之间的松耦合关系，可以很容易地新增或替换具体建造者类，从而扩展或修改构建过程，而不会影响到客户端代码。
    精确控制：通过建造者模式，可以精确地控制对象的构建过程，包括每个部分的构建顺序、构建时的参数设置等，从而得到更精确的结果。

- 缺点

    增加类数量：如果产品内部变化复杂，可能会产生很多的建造者类，导致系统变得庞大且难以维护。
    内部修改困难：如果产品内部发生变化，建造者也要相应修改，这可能会增加维护成本。

##### 五、与工厂模式的区别
    
    建造者模式与工厂模式都是创建型设计模式，但它们的注重点不同：

    建造者模式：更注重于方法的调用顺序，即如何一步步构建复杂对象。
    工厂模式：注重于创建产品，不关心方法调用的顺序。工厂模式通常用于创建单一类型的产品，而建造者模式则用于创建更为复杂的对象。

```java
public class HouseBuilder {

    public HouseBuilder setDepth() {
        return this;
    }

    public HouseBuilder setWidth() {
        return this;
    }

    public HouseBuilder setHeight() {
        return this;
    }

    public House build() {
        ///打地基
        ///砌墙壁
        ///楼板
        ///封顶
        ///门窗
        return new House(depth, width, height);
    }
    
}
```    

### 原型模式

原型模式（Prototype模式）是一种创建型设计模式，它的核心思想是通过复制现有的实例来创建新的对象，而不是通过实例化类来创建。这种模式允许一个对象再创建另外一个可定制的对象，而无需知道如何创建的细节。以下是关于原型模式的详细介绍：

- 优点：
性能高：使用原型模式复用的方式创建实例对象，比使用构造函数重新创建对象性能要高，特别是在类实例对象开销大的情况下。
流程简单：原型模式可以简化对象的创建过程，直接修改现有的对象实例的值，达到复用的目的，特别是在构造函数繁琐的情况下。
- 缺点：
实现复杂：必须重写对象的clone()方法，Java中虽然提供了Cloneable接口标识对象可以被拷贝，但具体实现时仍需覆盖Object的clone()方法。
深拷贝与浅拷贝风险：克隆对象时进行的一些修改容易出错，需要灵活运用深拷贝与浅拷贝操作。

```java
class Animator implements Cloneable {
    @Override
    public Animator clone() {
        try {
            final Animator anim = (Animator) super.clone();
            if (mListeners != null) {
                anim.mListeners = new ArrayList<AnimatorListener>(mListeners);
            }
            if (mPauseListeners != null) {
                anim.mPauseListeners = new ArrayList<AnimatorPauseListener>(mPauseListeners);
            }
            return anim;
        } catch (CloneNotSupportedException e) {
           throw new AssertionError();
        }
    }
}
```

## 结构型模式(7种)

### 适配器模式

### 装饰者模式

### 代理模式

### 外观模式

### 桥接模式

### 组合模式

### 享元模式

## 行为型模式(11种)

### 策略模式

### 模板方法模式

### 观察者模式

### 迭代器模式

### 职责链模式

### 命令模式

### 备忘录模式

### 状态模式

### 访问者模式