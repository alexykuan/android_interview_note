## 设计模式
### MVC(Model-View-Controller)

在Android中Activity通常作为view和controller的角色，而Model通常由网络请求、数据库、文件等组成。若果交互和页面比较复杂会导致Activity代码量过多，难以维护，所以MVC模式在Android中并不常用。

### MVP(Model-View-Presenter)

通常使用View接口来定义视图的行为，由Activity或者Fragment来实现View接口的行为，Presenter负责处理View和Model之间的交互。Presenter持有View和Model的引用，View持有Presenter的引用。

```kotlin

// View接口调用view的行为
interface IListPageView {

    fun showList(list: List<Any>)

    fun showEmpty(msg: String?)

    fun updateItemView(item: Any, index: Int?)
}

interface IListPagePresenter {

    fun loadList(params: Map<String, Any>)

    fun clickedItem(item: Any, index: Int)
}

class ListPagePresenterImpl(private val view: IListPageView) : IListPagePresenter {

    private val model = // Model实例 由网络接口提供或者数据库

    override fun loadList(params: Map<String, Any>) {
        // 调用Model获取数据
        val list = model.getList(params)
        view.showList(list)
    }

    override fun clickedItem(item: Any, index: Int) {
        // 调用Model处理点击事件
        model.changeItemData(item).observe {

        }
    }
}


class ListPageActivity : AppCompatActivity(), IListPageView {

    private val presenter: IListPagePresenter = ListPagePresenterImpl(this)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_list_page)
        presenter.loadList(mapOf())
    }

    override fun showList(list: List<Any>) {
        // 更新UI
    }

    showEmpty(msg: String?) {
        // 更新UI
    }

    override fun updateItemView(item: Any, index: Int?) {
        // 更新UI
    }
}

```

这个模式和mvp模式的区别在于，Presenter持有View的引用，而View持有Presenter的引用，Presenter和View之间是双向引用，Presenter可以调用View的方法，View也可以调用Presenter的方法。将mvp模式中对View的操作转移到了presenter中

### MVVM(Model-View-ViewModel)

ViewModel持有Model的数据，View持有ViewModel，但是控制ui的方便重新转移到了view里面，ViewModel只负责处理数据，不处理UI。将职责分离得更加彻底和清除，view只处理ui。

### MVI(Model-View-Intent)
